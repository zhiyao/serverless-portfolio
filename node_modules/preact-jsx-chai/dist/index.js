'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = assertJsx;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _preactRenderToStringJsx = require('preact-render-to-string/jsx');

var _preactRenderToStringJsx2 = _interopRequireDefault(_preactRenderToStringJsx);

/** Options for all assertions.
 *	@property {function} isJsx					A test to see if the given parameter is a JSX VNode. Defaults to checking for the existence of an __isVNode property
 */
var options = {
	/* If `false`, props with function values will be omitted from the comparison entirely */
	functions: true,
	/* If `false`, ignores function names and bound state, asserting only that the compared attributes are functions */
	functionNames: true
};

exports.options = options;
// options to pass to renderToString() when doing a deep comparison
var RENDER_OPTS = {
	sortAttributes: true
};

// options to pass to renderToString() when doing a shallow comparison
var SHALLOW_OPTS = _extends({}, RENDER_OPTS, {
	shallow: true
});

// for shallow comparisons, the "expected" value should NOT have high order components resolved at the root
var SHALLOW_OPTS_EXPECTED = _extends({}, SHALLOW_OPTS, {
	renderRootComponent: false
});

// for "includes" and "contains", pretty-print the diff but not the version that gets compared
var INCLUDE_RENDER_OPTS = _extends({}, RENDER_OPTS, {
	pretty: false
});

// create an assertion template string for the given action
var msg = function msg(act) {
	return 'expected #{act} to ' + act + ' #{exp}';
};

// assert that an object is JSX (or more correctly, a VNode)
var isJsx = function isJsx(obj) {
	return obj && (options.isJsx ? options.isJsx(obj) : obj.__isVNode || isVNode(obj));
};

// does it look like a vnode?
var isVNode = function isVNode(obj) {
	return obj.hasOwnProperty('nodeName') && obj.hasOwnProperty('attributes') && obj.hasOwnProperty('children') && obj.constructor.name === 'VNode';
};

// inject default options and invoke render with no context
var doRender = function doRender(jsx, opts) {
	return (0, _preactRenderToStringJsx2['default'])(jsx, null, _extends({
		functions: options.functions,
		functionNames: options.functionNames
	}, opts));
};

// inject a chai assertion if the values being tested are JSX VNodes
var ifJsx = function ifJsx(fn, opts, optsExpected, displayOpts) {
	return function (next) {
		return function (jsx) {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			if (!isJsx(this._obj)) return next.call.apply(next, [this, jsx].concat(args));
			var actual = doRender(this._obj, opts).trim();
			var expected = doRender(jsx, optsExpected || opts).trim();
			var diffActual = displayOpts ? doRender(this._obj, displayOpts).trim() : actual;
			var diffExpected = displayOpts ? doRender(jsx, displayOpts).trim() : expected;
			return fn(this, { expected: expected, actual: actual, diffActual: diffActual, diffExpected: diffExpected, jsx: jsx });
		};
	};
};

// create a passthrough function
var through = function through(next) {
	return function () {
		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return next.call.apply(next, [this].concat(args));
	};
};

// assert that a String is equal to the given string
var equal = function equal(a, _ref) {
	var expected = _ref.expected;
	var actual = _ref.actual;
	var diffExpected = _ref.diffExpected;
	var diffActual = _ref.diffActual;
	return a.assert(actual === expected, msg('equal'), msg('not equal'), diffExpected, diffActual, true);
};

// assert that a String contains the given string
var include = function include(a, _ref2) {
	var expected = _ref2.expected;
	var actual = _ref2.actual;
	var diffExpected = _ref2.diffExpected;
	var diffActual = _ref2.diffActual;
	return a.assert(~actual.indexOf(expected), msg('include'), msg('not include'), diffExpected, diffActual, true);
};

/** Middleware: pass to `chai.use()` to add JSX assertion support. */

function assertJsx(_ref3) {
	var Assertion = _ref3.Assertion;

	if (Assertion.__assertJsxMounted === true) return;
	Assertion.__assertJsxMounted = true;

	Assertion.overwriteMethod('eql', ifJsx(equal, RENDER_OPTS));
	Assertion.overwriteMethod('eqls', ifJsx(equal, RENDER_OPTS));

	Assertion.overwriteMethod('equal', ifJsx(equal, SHALLOW_OPTS, SHALLOW_OPTS_EXPECTED));
	Assertion.overwriteMethod('equals', ifJsx(equal, SHALLOW_OPTS, SHALLOW_OPTS_EXPECTED));

	['include', 'includes', 'contain', 'contains'].forEach(function (method) {
		Assertion.overwriteChainableMethod(method, ifJsx(include, INCLUDE_RENDER_OPTS, INCLUDE_RENDER_OPTS, RENDER_OPTS), through);
	});
}

assertJsx.options = options;

// auto-mount if possible
if (typeof chai !== 'undefined' && chai.use) chai.use(assertJsx);
//# sourceMappingURL=data:application/json;base64,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QUFTLENBQUMsa0JBQWtCLEtBQUcsSUFBSSxFQUFFLE9BQU87QUFDaEQsVUFBUyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQzs7QUFFcEMsVUFBUyxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQzVELFVBQVMsQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQzs7QUFFN0QsVUFBUyxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUUscUJBQXFCLENBQUMsQ0FBQyxDQUFDO0FBQ3RGLFVBQVMsQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLHFCQUFxQixDQUFDLENBQUMsQ0FBQzs7QUFFdkYsRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQyxPQUFPLENBQUUsVUFBQSxNQUFNLEVBQUk7QUFDakUsV0FBUyxDQUFDLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLFdBQVcsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0VBQzNILENBQUMsQ0FBQztDQUNIOztBQUVELFNBQVMsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDOzs7QUFHNUIsSUFBSSxPQUFPLElBQUksS0FBRyxXQUFXLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlbmRlciBmcm9tICdwcmVhY3QtcmVuZGVyLXRvLXN0cmluZy9qc3gnO1xuXG4vKiogT3B0aW9ucyBmb3IgYWxsIGFzc2VydGlvbnMuXG4gKlx0QHByb3BlcnR5IHtmdW5jdGlvbn0gaXNKc3hcdFx0XHRcdFx0QSB0ZXN0IHRvIHNlZSBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGEgSlNYIFZOb2RlLiBEZWZhdWx0cyB0byBjaGVja2luZyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBfX2lzVk5vZGUgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGNvbnN0IG9wdGlvbnMgPSB7XG5cdC8qIElmIGBmYWxzZWAsIHByb3BzIHdpdGggZnVuY3Rpb24gdmFsdWVzIHdpbGwgYmUgb21pdHRlZCBmcm9tIHRoZSBjb21wYXJpc29uIGVudGlyZWx5ICovXG5cdGZ1bmN0aW9uczogdHJ1ZSxcblx0LyogSWYgYGZhbHNlYCwgaWdub3JlcyBmdW5jdGlvbiBuYW1lcyBhbmQgYm91bmQgc3RhdGUsIGFzc2VydGluZyBvbmx5IHRoYXQgdGhlIGNvbXBhcmVkIGF0dHJpYnV0ZXMgYXJlIGZ1bmN0aW9ucyAqL1xuXHRmdW5jdGlvbk5hbWVzOiB0cnVlXG59O1xuXG4vLyBvcHRpb25zIHRvIHBhc3MgdG8gcmVuZGVyVG9TdHJpbmcoKSB3aGVuIGRvaW5nIGEgZGVlcCBjb21wYXJpc29uXG5jb25zdCBSRU5ERVJfT1BUUyA9IHtcblx0c29ydEF0dHJpYnV0ZXM6IHRydWVcbn07XG5cbi8vIG9wdGlvbnMgdG8gcGFzcyB0byByZW5kZXJUb1N0cmluZygpIHdoZW4gZG9pbmcgYSBzaGFsbG93IGNvbXBhcmlzb25cbmNvbnN0IFNIQUxMT1dfT1BUUyA9IHtcblx0Li4uUkVOREVSX09QVFMsXG5cdHNoYWxsb3c6IHRydWVcbn07XG5cbi8vIGZvciBzaGFsbG93IGNvbXBhcmlzb25zLCB0aGUgXCJleHBlY3RlZFwiIHZhbHVlIHNob3VsZCBOT1QgaGF2ZSBoaWdoIG9yZGVyIGNvbXBvbmVudHMgcmVzb2x2ZWQgYXQgdGhlIHJvb3RcbmNvbnN0IFNIQUxMT1dfT1BUU19FWFBFQ1RFRCA9IHtcblx0Li4uU0hBTExPV19PUFRTLFxuXHRyZW5kZXJSb290Q29tcG9uZW50OiBmYWxzZVxufTtcblxuLy8gZm9yIFwiaW5jbHVkZXNcIiBhbmQgXCJjb250YWluc1wiLCBwcmV0dHktcHJpbnQgdGhlIGRpZmYgYnV0IG5vdCB0aGUgdmVyc2lvbiB0aGF0IGdldHMgY29tcGFyZWRcbmNvbnN0IElOQ0xVREVfUkVOREVSX09QVFMgPSB7XG5cdC4uLlJFTkRFUl9PUFRTLFxuXHRwcmV0dHk6IGZhbHNlXG59O1xuXG4vLyBjcmVhdGUgYW4gYXNzZXJ0aW9uIHRlbXBsYXRlIHN0cmluZyBmb3IgdGhlIGdpdmVuIGFjdGlvblxubGV0IG1zZyA9IGFjdCA9PiBgZXhwZWN0ZWQgI3thY3R9IHRvICR7YWN0fSAje2V4cH1gO1xuXG4vLyBhc3NlcnQgdGhhdCBhbiBvYmplY3QgaXMgSlNYIChvciBtb3JlIGNvcnJlY3RseSwgYSBWTm9kZSlcbmxldCBpc0pzeCA9IG9iaiA9PiBvYmogJiYgKG9wdGlvbnMuaXNKc3ggPyBvcHRpb25zLmlzSnN4KG9iaikgOiAob2JqLl9faXNWTm9kZSB8fCBpc1ZOb2RlKG9iaikpKTtcblxuLy8gZG9lcyBpdCBsb29rIGxpa2UgYSB2bm9kZT9cbmxldCBpc1ZOb2RlID0gb2JqID0+IG9iai5oYXNPd25Qcm9wZXJ0eSgnbm9kZU5hbWUnKSAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2F0dHJpYnV0ZXMnKSAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2NoaWxkcmVuJykgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWU9PT0nVk5vZGUnO1xuXG4vLyBpbmplY3QgZGVmYXVsdCBvcHRpb25zIGFuZCBpbnZva2UgcmVuZGVyIHdpdGggbm8gY29udGV4dFxubGV0IGRvUmVuZGVyID0gKGpzeCwgb3B0cykgPT4gcmVuZGVyKGpzeCwgbnVsbCwge1xuXHRmdW5jdGlvbnM6IG9wdGlvbnMuZnVuY3Rpb25zLFxuXHRmdW5jdGlvbk5hbWVzOiBvcHRpb25zLmZ1bmN0aW9uTmFtZXMsXG5cdC4uLm9wdHNcbn0pO1xuXG4vLyBpbmplY3QgYSBjaGFpIGFzc2VydGlvbiBpZiB0aGUgdmFsdWVzIGJlaW5nIHRlc3RlZCBhcmUgSlNYIFZOb2Rlc1xubGV0IGlmSnN4ID0gKGZuLCBvcHRzLCBvcHRzRXhwZWN0ZWQsIGRpc3BsYXlPcHRzKSA9PiBuZXh0ID0+IGZ1bmN0aW9uKGpzeCwgLi4uYXJncykge1xuXHRpZiAoIWlzSnN4KHRoaXMuX29iaikpIHJldHVybiBuZXh0LmNhbGwodGhpcywganN4LCAuLi5hcmdzKTtcblx0bGV0IGFjdHVhbCA9IGRvUmVuZGVyKHRoaXMuX29iaiwgb3B0cykudHJpbSgpO1xuXHRsZXQgZXhwZWN0ZWQgPSBkb1JlbmRlcihqc3gsIG9wdHNFeHBlY3RlZCB8fCBvcHRzKS50cmltKCk7XG5cdGxldCBkaWZmQWN0dWFsID0gZGlzcGxheU9wdHMgPyBkb1JlbmRlcih0aGlzLl9vYmosIGRpc3BsYXlPcHRzKS50cmltKCkgOiBhY3R1YWw7XG5cdGxldCBkaWZmRXhwZWN0ZWQgPSBkaXNwbGF5T3B0cyA/IGRvUmVuZGVyKGpzeCwgZGlzcGxheU9wdHMpLnRyaW0oKSA6IGV4cGVjdGVkO1xuXHRyZXR1cm4gZm4odGhpcywgeyBleHBlY3RlZCwgYWN0dWFsLCBkaWZmQWN0dWFsLCBkaWZmRXhwZWN0ZWQsIGpzeCB9KTtcbn07XG5cbi8vIGNyZWF0ZSBhIHBhc3N0aHJvdWdoIGZ1bmN0aW9uXG5sZXQgdGhyb3VnaCA9IG5leHQgPT4gZnVuY3Rpb24oLi4uYXJncykgeyByZXR1cm4gbmV4dC5jYWxsKHRoaXMsIC4uLmFyZ3MpOyB9O1xuXG4vLyBhc3NlcnQgdGhhdCBhIFN0cmluZyBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gc3RyaW5nXG5sZXQgZXF1YWwgPSAoYSwgeyBleHBlY3RlZCwgYWN0dWFsLCBkaWZmRXhwZWN0ZWQsIGRpZmZBY3R1YWwgfSkgPT4gYS5hc3NlcnQoYWN0dWFsPT09ZXhwZWN0ZWQsIG1zZygnZXF1YWwnKSwgbXNnKCdub3QgZXF1YWwnKSwgZGlmZkV4cGVjdGVkLCBkaWZmQWN0dWFsLCB0cnVlKTtcblxuLy8gYXNzZXJ0IHRoYXQgYSBTdHJpbmcgY29udGFpbnMgdGhlIGdpdmVuIHN0cmluZ1xubGV0IGluY2x1ZGUgPSAoYSwgeyBleHBlY3RlZCwgYWN0dWFsLCBkaWZmRXhwZWN0ZWQsIGRpZmZBY3R1YWwgfSkgPT4gYS5hc3NlcnQofmFjdHVhbC5pbmRleE9mKGV4cGVjdGVkKSwgbXNnKCdpbmNsdWRlJyksIG1zZygnbm90IGluY2x1ZGUnKSwgZGlmZkV4cGVjdGVkLCBkaWZmQWN0dWFsLCB0cnVlKTtcblxuXG4vKiogTWlkZGxld2FyZTogcGFzcyB0byBgY2hhaS51c2UoKWAgdG8gYWRkIEpTWCBhc3NlcnRpb24gc3VwcG9ydC4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzc2VydEpzeCh7IEFzc2VydGlvbiB9KSB7XG5cdGlmIChBc3NlcnRpb24uX19hc3NlcnRKc3hNb3VudGVkPT09dHJ1ZSkgcmV0dXJuO1xuXHRBc3NlcnRpb24uX19hc3NlcnRKc3hNb3VudGVkID0gdHJ1ZTtcblxuXHRBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWwnLCBpZkpzeChlcXVhbCwgUkVOREVSX09QVFMpKTtcblx0QXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXFscycsIGlmSnN4KGVxdWFsLCBSRU5ERVJfT1BUUykpO1xuXG5cdEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxdWFsJywgaWZKc3goZXF1YWwsIFNIQUxMT1dfT1BUUywgU0hBTExPV19PUFRTX0VYUEVDVEVEKSk7XG5cdEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxdWFscycsIGlmSnN4KGVxdWFsLCBTSEFMTE9XX09QVFMsIFNIQUxMT1dfT1BUU19FWFBFQ1RFRCkpO1xuXG5cdFsnaW5jbHVkZScsICdpbmNsdWRlcycsICdjb250YWluJywgJ2NvbnRhaW5zJ10uZm9yRWFjaCggbWV0aG9kID0+IHtcblx0XHRBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKG1ldGhvZCwgaWZKc3goaW5jbHVkZSwgSU5DTFVERV9SRU5ERVJfT1BUUywgSU5DTFVERV9SRU5ERVJfT1BUUywgUkVOREVSX09QVFMpLCB0aHJvdWdoKTtcblx0fSk7XG59XG5cbmFzc2VydEpzeC5vcHRpb25zID0gb3B0aW9ucztcblxuLy8gYXV0by1tb3VudCBpZiBwb3NzaWJsZVxuaWYgKHR5cGVvZiBjaGFpIT09J3VuZGVmaW5lZCcgJiYgY2hhaS51c2UpIGNoYWkudXNlKGFzc2VydEpzeCk7XG4iXX0=